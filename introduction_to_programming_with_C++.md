# C++程序设计基础(第5版)上 周霭如 林伟健编著
## 第1章 基本数据与表达式  

__"*"__ 在地址值之前是指针运算符; 在变量说明语句中是指针类型符  
取值运算符是 __"&"__  

\*a(a是指针) -> 对象
&a(a是对象) -> 地址  
\*(&a) -> a

能够存放地址值的变量称为"指针类型变量", 简称"指针变量"  
用*p1 的这种访问方式, 称为间接地址访问, 简称为间址访问  

引用说明为对象建立引用名, 即别名. "="的意义是在定义时与对象名绑定, 程序
中不能对引用重定义. 一个对象的别名, 在使用方式和效果上, 与使用对象名一致.
引用仅仅是对象的别名, 不开辟新的内存空间.

关键字 __const__ 可以约束对象的访问性质, 使对象值一旦初始化就不允许修改,
被约束为只读的对象称为常对象.
1. 标识常量
C++语言中, 当用关键字 const约束基本类型存储单元为只读时, 在程序中使用存储单元的名字就像使用常数值一样, 即用标识符表示数值, 所以称为表示常量, 简称常量.
const 类型 常量标识符 = 常量表达式;
2. 指向常量的指针
用 const约束指针对所指对象访问时, 这个指针称为指向常量的指针
const 类型 \*指针  或者  类型 const \*指针
const 写在关联类型之前或者紧跟关联类型之后, 表示约束所指对象访问.
3. 指针常量
指针常量的意义是指针变量的值只能在定义的时候初始化, 定义后不能修改, 即不能改变指针变量的指向. 但不影响所指对象的访问特性.
类型 \* const 指针
4. 指向常量的指针变量
指针本身和所指对象的值在定义之后都限制为只读, 不能写
const 类型 \* const 指针  或者  类型 const \* const 指针
5. 常引用
冠以 const定义的引用, 将约束对象用别名方式访问时为只读
const 类型 & 引用名 = 对象名

## 第3章 函数
函数是功能的抽象. 所谓功能抽象, 是指这个程序模块定义的操作, 适用于指定数据类型的数据集.

函数原型是函数的生命, 作用是告诉编译器有关函数接口的信息: 函数的名字、函数返回值的数据类型、函数的参数个数、参数类型和参数的顺序, 编译器根据函数原型检查函数调用的正确性

C++语言有三种参数传递机制: 值传递(值调用)、指针传递(地址调用)和引用传递(引用调用)
1. 值传递机制
在值传递机制中, 作为实际参数的表达式的值被复制到由对应的形式参名所表示的对象中, 成为形参的初始值. 完成参数值传递之后, 函数体中的语句对形参的访问、修改都是在这个标识对象上操作的, 与实际参数对象无关.
2. 实际参数求值的副作用
C++没有规定在函数调用时实际参数的求值顺序. 实际参数求值顺序的不同规定, 对一般参数没有什么影响, 但若实际参数表达式之间有求值关联, 则同一个程序在不同编译器可能产生不同的运行结果
这种存在复制依赖关系的传值参数称为有副作用的参数. 为了避免这种情况, 可以在调用函数之前先执行修改变量的表达式, 以消除实参表达式求值的依赖关系.
3. 默认参数
默认参数应该在函数名第一次出现时指定, 通常在函数原型中. 若已在函数原型中指定默认参数, 则函数定义时不能重复给出

指针参数
函数定义中的形式参数被说明为指针类型时, 称为指针参数. 形参指针对应的实际参数是地址表达式. 调用函数时, 实际参数把对象的地址值赋给形式参数名标识的指针变量, 被调用函数可以在函数体内通过形参指针来间接访问实参地址所指的对象. 这种参数传递方式称为指针传递或地址调用

引用参数
如果C++函数的形式参数被定义为引用类型, 则称为引用参数. 引用参数对应的实际参数应该是对象名. 函数被调用时, 形式参数不需要开辟新的存储空间, 形式参数名作为引用(别名)绑定于实际参数标识的对象上. 执行函数体时, 对形参的操作就是对实参对象操作. 直到函数执行结束, 撤销引用绑定

一个已经定义的函数, 它的名字就是函数的入口地址.
1. 函数的类型
C++中, 可以用关键字 typedef定义函数类型名.
typedef 类型 函数类型名(形式参数表);
2.函数指针
要定义指向某一类函数的指针变量, 可以用一下两种说明语句:
类型 (\* 指针变量名) (形式参数表);  或  函数类型 \* 指针变量名
还可以用关键字 typedef定义指针类型.
typedef 类型 (* 指针类型) (形式参数表);  或  typedef 函数类型 * 指针类型
3. 用函数指针调用函数
(* 指针变量名) (实际参数表)  或  指针变量名 (实际参数表)

静态存储
关键字 __extern__ 和 __static__ 说明静态存储变量和函数标识符. 全局说明的标识符默认为 extern.
如果这两个关键字用于说明变量, 程序在开始执行时就分配和初始化存储空间; 如果用于说明函数, 表示程序执行开始就存在这个函数名.
尽管标识符被说明为静态时, 程序一开始执行就存在, 但不等于他们在整个程序中可用. 用 static说明的局部变量只能在定义该变量的函数体中使用. 与自动变量不同的是, static在第一次使用时进行初始化(默认初始化的值为 0). 函数退出时, 系统保持其存储空间和数值. 下次调用这个函数时, static变量还是上次退出函数时的值.

宏定义指令 #define用来指定正文替换程序中出现的标识符

条件编译
\#ifndef 标识符
&ensp;&ensp;&ensp;&ensp;\#define 标识符
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;程序文本
&ensp;&ensp;&ensp;&ensp;\#endif
若"标识符"没有定义, 则"程序文本"被编译, 若"标识符"已经定义, 则"程序文本"被忽略.

终止程序执行
1. abort函数
函数原型: void abort(void);
功能: 中断程序的执行, 返回 C++系统的主窗口. 该函数在 cstlib头文件声明.
2. assert函数
函数原型: void assert(int expression);
功能: 计算表达式 expression的值, 若该值为 false, 则中断程序的执行, 显示中断执行所在文件和程序行, 返回 C++系统的主窗口. 该函数在 cassert头文件声明.
3. exit函数
函数原型: void exit(int status);
功能: 中断程序的执行, 返回退出代码, 回到 C++系统的主窗口. 该函数在 cstdlib头文件中声明. 其中, 参数 status是整型常量, 终止程序时把它作为退出代码返回操作系统, C++看不到 exit的返回值.

## 第4章 数组
\*(p++)相当于: 先读 \*p输出, 然后执行 p++

C++的高位数组在内存中以高维优先的方式存放.

当数组元素作为参数时, 它的性质与简单变量相同; 当数组名作为参数时, 实现地址传送. 数组元素和数组名都可以作为引用参数.

数组指针访问时, 指针离开动态分配的存储区, 这时执行 delete, 系统将无法释放已分配的内存. 这就是所谓的 __"内存泄露"__ 问题, 是一个十分严重的错误.

C++对串常量自动添加结束标志 '\0', 由串常量定义串的长度, 长度 +1.
对字符指针可以用串常量初始化, 实际上系统完成两步操作: 首先申请堆空间, 然后填入串值.

## 第5章 集合与结构
结构类型是用户自定义数据类型, 以关键字 struct标识, 由结构类型名、各成员的名称和类型定义.
struct 标识符
{&ensp;&ensp;类型 成员1;
&ensp;&ensp;&ensp;类型 成员2;
&ensp;&ensp;&ensp;...
&ensp;&ensp;&ensp;类型 成员n;
}
用指针访问结构, 所指对象包含了结构的数据成员, 访问形式为:
\*(指针).成员  或  指针 -> 成员

## 第6章 类与对象
成员函数在类外定义使用作用域区分符进行说明:
返回类型 类名::函数名 (参数表)
成员函数有两个作用: 一是操作数据成员, 包括访问和修改数据成员; 二是用于协同不同的对象操作, 称为传递消息.

复制构造函数
用户自定义的复制构造函数用于完成更为复杂的操作.
要求有一个类类型的引用参数:
类名::类名(const 类名 & 引用名, ...);

类的其他成员
1. 常数据成员
2. 常对象
若在定义对象的说明语句以 const作前缀, 则该对象称为常对象. 这个对象的全部数据成员在作用域中约束为只读.
3. 常成员函数
常成员函数的this指针被约束为指向常量的常指针. 由于 this指针隐含定义, 因此常成员函数在函数头以关键字 const作为后缀.
相当于常成员函数的 this指针类型为:
const X \* const this
4. 静态成员
当类成员冠以 static声明时, 称为静态成员. "静态"是指它的作用域局部于类. 一个类可以创建多个对象, 因此, 静态成员提供了一种同类对象的共享机制; "成员"是指它与普通类成员一样受不同访问特性的约束.
5. 静态成员函数
当一个成员函数冠以 static声明时, 称为静态成员函数. 静态成员函数提供了一个不依赖于类数据结构的共同操作, 它没有 this指针. 因为静态成员函数只能访问类的静态数据成员, 所以设计静态成员函数与静态数据成员可协同操作.

友元
一个对象的私有数据, 只能通过成员函数访问.
C++语言提供了一种辅助手段 -> 定义类的友元. 友元可以访问类的所有成员, 包括私有成员. 友元可以是一个普通函数、成员函数或另一个类.
1. 友元函数
友元函数 FriendFun必须在参数表中显式地指明要访问的对象 Aobj, 而成员函数 MemberFun 则在它的对象 Aobj上操作.
2. 友元类
若 F类是 A类的友元类, 则 F类的所有成员函数都是 A类的友元函数. 在程序中, 友元类通常设计为一种对数据操作或类之间传递消息的辅助类.

类的包含(has-a)
首先要调用成员类的构造函数, 然后执行自身的构造函数完成初始化操作.

## 第7章 运算符重载
运算符函数是一种特殊的成员函数或友元函数.
类型 类名::operator op(参数表)
{
&ensp;&ensp;//相对于该类定义的操作
}

赋值运算符重载用于对象数据的复制, 只能用成员函数重载.
类名 & 类名::operator=(类名)

运算符 "[]" 和 "()" 只能用成员函数重载, 不能用友元函数重载.

具有一个非默认参数的构造函数能够把某种类型对象转换成指定类度对象, 但不能将一个类对象转换为基本类型数据. 为此 C++引入一种特殊的成员函数 -> 类型转换函数.
Class X::operator Type()
{
&ensp;&ensp;//...
&ensp;&ensp;return Type_Value;
}

## 第8章 继承
虚继承
把类格中不同路径的公共基类定义为"虚基类". 虚继承的说明形式是在类继承的关键字之前添加关键字 virtual. 当建立派生类的对象时, 其存储空间只包含一个顶层基类. 此时, 不再分别建立基类, 而由 virtual指引建立指向基类的指针.

## 第9章 虚函数与多态性
静态联编
联编是指一个程序模块、代码之间互相关联的过程. 根据联编的时机, 可以分为静态联编和动态联编.
所谓静态联编, 是指程序之间的匹配、连接在编译阶段, 即程序运行之前完成, 也称为早期匹配. 大量的程序代码是静态联编的. 例如, 调用一个已经说明的函数, 编译期间就能准确获得函数入口地址、返回地址和参数传递的信息, 从而完成匹配.
动态联编是指程序联编推迟到运行时进行, 所以又称为晚期联编. switch语句是一个动态联编的例子. 程序编译阶段不能预知 switch表达式的值, 一直要等到程序运行时, 对表达式求值之后, 才能实现 case字句匹配, 决定代码执行的分支. 需要进行条件判断决定程序流程的条件语句、循环语句的情况也相同.
重载函数要根据类型、参数进行匹配, 一般在编译阶段进行静态联编. 实际上都是根据类或对象来确定成员函数隐式参数 this指针的不同关联类型, 因此重载函数在编译阶段即完成匹配.

类指针的关系
C++的动态联编依赖虚函数和基类指针实现.
派生类指针只有经过强制类型转换之后, 才能引用基类对象.

虚函数和动态联编
冠以关键字 virtual的成员函数称为虚函数.
实现运行时多态的关键是先要说明虚函数, 而且必须用基类指针调用派生类的不同实现版本. 尽管可以像调用其他成员函数那样, 显示地用对象名来调用一个虚函数, 但只有使用同一个基类指针访问虚函数, 才称为运行时的多态.
虚函数和基类指针
基类指针不需要经过类型转换就可以指向派生类对象, 这是一个重要的事实. 但是, 基类指针虽然可以获取派生类对象的地址, 却只能访问派生类从基类继承的成员.
C++提供的虚函数解释机制, 让基类指针可以依赖运行时的地址值(当前指向)调用不同类版本的成员函数. 实际上, 这表达了一种运行时的动态性质.
虚函数和基类指针的解释机制实现了程序运行时的单界面, 多实现版本. 基类可以用虚函数提供一个与派生类相同的界面, 允许派生类定义自己的实现版本. 虚函数调用的解释依赖于调用它的对象类型, 使基类指针指向不同派生类的对象时自动完成 this指针的类型转换, 以访问虚函数在派生类不同的实现版本. 运行时的多态成为许多 C++程序设计的关键.

定义虚函数注意一下4点:
1. 一旦一个成员函数被说明为虚函数, 则不管经历多少派生类层次, 所有界面相同的重载函数都保持虚特性. 因为派生类也是基类.
2. 虚函数必须是类的成员函数. 不能将虚函数说明为全局(非成员)函数, 也不能说明为静态成员函数. 因为虚函数的动态联编必须在类层次中依靠 this指针实现.
3. 不能将友元说明为虚函数, 但虚函数可以是另一个类的友元.
4. 析构函数可以是虚函数, 但构造函数不能是虚函数.

虚函数的重载特性
在一个派生类中重定义基类的虚函数是函数重载的一种特殊形式, 它不同于一般函数的重载. 当重载一般函数时, 函数的返回类型和参数的个数、类型可能不相同, 仅要求函数名相同. 但重载一个虚函数时, 要求函数名、返回类型、参数个数、参数类型和顺序完全相同. 否则, 会出现以下问题:
1. 如果仅仅返回类型不同, 其余相同, 则 C++认为是错误重载, 因为只靠返回类型不同的信息进行函数匹配是含糊的.
2. 如果函数原型不同, 仅函数名相同, 则 C++认为是一般函数重载, 因而丢失虚特性.
究其原因, 类层次重载的各个虚函数, 表面上他们的类型相同(函数名、参数集相同), 但隐含的 this指针类型不同, 其关联类型分别是重载他们的派生类. 虚函数是仅由 this指针类型区分接口的函数, C++的"虚"特性仅负责在程序运行时把基类 this指针的关联类型转换成当前指向对象的类类型, 而不能改变函数其他参数的性质.

析构函数可以是虚的. 虚析构函数用于动态建立类对象时, 指引 delete运行符选择正确的析构调用.

纯虚函数和抽象类
一个具有纯虚函数的基类称为抽象类. 抽象类机制支持一般概念的表示, 也可以用于定义接口.
纯虚函数
virtual 类型 函数名(参数表) = 0;
其中, "函数名"是纯虚函数名. 该函数复制为0, 表示没有实现定义. 虚函数的实现在它的派生类中定义.
抽象类
至少有一个纯虚函数.
如果抽象类的一个派生类没有为继承的纯虚函数定义实现版本, 那么, 它仍然是抽象类.
1. 抽象类只能用作其他类的基类;
2. 抽象类不能建立对象;
3. 抽象类不能用作参数类型, 函数返回类型或显式类型转换.
可以说明抽象类的指针和引用
抽象类指针 p通过获取不同派生类对象地址来改变指向, 利用多态特性调用纯虚函数在派生类中的不同实现版本.

## 第10章 模板
模板说明
template <class T1, class T2, ..., class Tn>
template <typename T1, typename T2, ..., typename Tn>

类模板
一个类模板是类定义的一种模式, 用于实现数据类型参数化的类.
template <typename Type>
class TClass
{
&ensp;&ensp;//TClass的成员函数
private:
&ensp;&ensp;Type DateMember;
&ensp;&ensp;//...
};
类属参数必须至少在类说明中出现一次.
类模板在表示数据结构, 如数组、表、图等时, 显得特别重要, 因为这些数据结构的表示和算法通常不受所包含的元素类型的影响.

类模板作为函数参数
函数的形式参数类型可以是类模板或类模板的引用. 调用时对应的实际参数是该类模板实例化的模板类对象.
当一个函数拥有类模板参数时, 这个函数必定是函数模板.

在类层次中的类模板
一个类模板在类层次结构中, 既可以是基类, 也可以是派生类, 即:
- 类模板可以从类模板派生或从普通类(非模板类)派生;
- 模板类可以从类模板派生或普通类派生.
当一个类模板从普通类派生时. 意味着派生类增加了类属参数; 当一个模板类从类模板派生时, 意味着派生类继承基类时提供了实例化的类型参数.
若从一个类模板派生一个普通类, 在定义这个派生类时就要对基类的类属参数实例化, 实际上, 这个派生类是一个通过基类生成的模板类.

类模板与友元
在类模板中, 与普通类一样, 可以声明各种友元关系: 一个函数或函数模板可以说明为类或类模板的友元, 一个类或类模板可以说明为类或类模板的友元类. 要声明这种模板之间的友元关系, 由于既有模板声明, 又有友元声明, 所以使用的语法符号比较烦琐.
1. 模板类的友元函数
template<typename T> class X
{&ensp;&ensp;//...
&ensp;&ensp;&ensp;void f1();
}
template<typename T> class X
{&ensp;&ensp;//...
&ensp;&ensp;&ensp;template<typename T> friend void f2(X<T> &);
}
2. 模板类的友元类
一个模板类的友元可以是一个已经定义的类或类模板
以下声明Y类的每个成员函数称为类模板X实例化的每个模板类的友元函数:
template<typename T> class X
{&ensp;&ensp;//...
&ensp;&ensp;&ensp;friend class Y;
}
当类模板的友元类也是类模板时, 有
template<typename T> class X
{&ensp;&ensp;//...
&ensp;&ensp;&ensp;template<typename T> friend class Z;
}

标准模板
__标准模板库(Standard Template Library, STL)__ 中有三个主要组件: __容器(container)__ 、__迭代器(iterator)__ 和 __算法(algorithm)__.

容器分类
STL容器分成三大类: __序列容器(sequence container)__ 、 __关联容器(associative container)__ 和 __容器适配器(container adapter)__
另外 C语言式数组和 string, 称为 __近容器(near container)__
1. 序列容器 -> 提供顺序表的表示和操作
> vector: 向量. 可以随机访问序列中的单个元素, 在序列尾快读插入和删除元素. 如果在序列中插入和删除元素, 则时间与序列长度成正比
> deque: 双向队列. 随机访问序列中的单个元素, 可以在序列头或尾快读插入和删除元素. 如果在序列中插入和删除元素, 则时间与序列长度成正比.
> list: 双向链表. 用的动态链式存放数据, 可以从任何位置快读插入和删除元素.

2. 关联容器 -> 提供集合和映像的表示和操作
> set: 集合. 无重复值元素, 可以快读查找.
> multiset: 集合. 允许重复值元素, 可以快读查找.
> map: 映射. 一对一映射, 无重复值无缘, 实现基于关键字的快速查找.
> multimap: 映射. 一对多映射, 允许重复值元素, 实现基于关键字的快速查找

3. 容器适配器 -> 特殊顺序表
> stack(堆栈): 后进先出(Last-In, First-Out, LIFO)表, 只能在表头插入和删除元素.
> queue(队列): 先进先出(First-In, First-Out, FIFO)表, 只能在表头删除元素, 正在表尾插入元素.
> priority_queue(优先队列): 优先级最高的元素总是第一个出列.

容器的接口
c.push_back(elem) 在容器末端插入数据 elem
c.pop_back() 删除容器末端数据

迭代器
- 输入(input) -> 从容器中顺向读取元素;
- 输出(output) -> 向容器顺向写入元素;
- 正向(forward) -> 顺向读/写容器的元素;
- 双向(bidirectional) -> 顺向或逆向读/写容器的元素;
- 随机访问(random access) -> 顺向或逆向读/写容器的元素, 可以跳过任意个元素.

算法
算法在头文件algorithm中声明
1. find
函数的功能是返回容器指定范围中元素值等于查找关键字的迭代.
template<typename InputIterator, typename T> inline
InputIterator find(InputIterator first, InputIterator last, const T & value)
其中, InputIterator表示输入迭代器, first, last表示查找起止范围的迭代, value是查找关键字.
2. find_if
函数的功能是按容器的指定范围查找, 并返回第一个满足测试条件的元素的迭代.
template<class InputIterator, class T, class Predicate> inline
InputIterator find_if(InputIterator first, InputIterator last, Predicate predicate)
其中, 形式参数 predicate是函数指针, Predicate表示返回逻辑值的一元函数, 通过 predicate调用测试函数.
3. sort
第一个版本的算法, 对容器的元素按升序(不降序列)排序.
第二个版本的算法, 由函数指针参数 pr调用函数指定序列关系. Pred表示返回逻辑值的二元函数.
template<class RanIt>
void sort(RanIt first, RanIt last);
template<class RanIt, class Pred>
void sort(RanIt first, RanIt last, Pred pr);
其中, RanIt表示随机访问迭代器. first和 last是指定排序范围的迭代.
4. binary_search
用于查找有序表指定关键字的元素
template<class FwdIt, class T>
bool binary_search(FwdIt first, FwdIt last, const T & val);
template<class FwdIt, class T, class Pred>
bool binary_search(FwdIt first, FwdIt last, const T & val, Pred, pr);
其中, FwdIt表示正向访问迭代器.
第一个版本用于查找升序表.
第二个版本用于查找降序表. 参数pr 用于调用测试函数. 其含义与 sort函数的相同.
