# 算法导论(Introduction to Algorithm)
## 第一章 算法在计算中的作用
### 1.1 算法
__算法(algorithm)__ 就是任何良定义的计算过程, 该过程取某个值或值的集合作为 __输入__ 并产生某个值或值的集合作为 __输出__. 这样算法就是把输入转换成输出的计算步骤的一个序列
```mermaid
graph TD
A(输入) -->|算法| B(输出)
```  
一个合法的输入序列称为排序问题的一个 __实例(instance)__

算法问题共有的两个特征
1. 存在许多候选解, 但绝大多数候选解都没有解决手头的问题.
2. 存在实际应用

### 1.2 作为一种技术的算法
算法与其他技术
- 先进的计算机体系结构与制造技术
- 易于使用、 直观的图形用户界面(GCU)
- 面向对象的系统
- 集成的万维网技术
- 有线与无线网络的快速组网

## 第二章 算法基础
### 2.1 插入排序
循环不变式性质:
- __初始化__: 循环的第一次迭代之前, 它为真.
- __保持__: 如果循环的某次迭代之前它为真, 那么下次迭代之前它仍为真.
- __终止__: 在循环终止时, 不变式为我们提供一个有用的性质, 该性质有助于证明算法是正确的

__伪代码__ 中的一些约定
- 缩进表示块结构
- for循环每次迭代增加其循环计数器时, 我们使用关键词 __to__. 当一个for循环每次迭代减少其循环计数器时, 我们使用关键词 __downto__
- 符号"//"表示该行后面部分是个注释
- 记号".."用于表示数组中值的一个范围
- 复合数据结构被组织成对象, 对象又由属性组成. 我们使用许多面向对象编程语言中创建的句法来访问特定的属性: 对象名后跟一个点再跟属性名  
  我们把表示一个数组或对象的变量看做指向表示数组或对象的数据的一个指针  
  有时, 一个指针根本不指向任何对象. 这是, 我们赋给它特殊值 __NIL__
- 我们按__值__把参数传递给过程: 被调用过程接受其参数自身的副本. 如果它对某个参数赋值, 调用过程看不到这种改变
- 一个 __return__ 语句立即将控制返回到调用过程的调用点.  
  我们允许在单一的 __return__ 语句中返回多个值
- 布尔运算符"and"和"or"都是 __短路的__
- 关键词 __error__ 表示因为已被调用的过程情况不对而出现了一个错误. 调用过程负责处理该错误, 所以我们不用说明将采取什么行动

### 2.2 分析算法
我们真正感兴趣的是运行时间的 __增长率__ 或 __增长量级__

### 2.3 设计算法
#### 2.3.1 分治法
__分治法__ 的思想: 将原问题分解为几个规模较小但类似于原问题的子问题, 递归地求解这些子问题, 然后再合并这些子问题的解来建立原问题的解.
__分治模式__ 在每层递归时都有三个步骤:
- __分解__ 原问题为若干子问题, 这些子问题是原问题的规模较小的实例.
- __解决__ 这些子问题, 递归地求解各子问题. 然而, 若子问题的规模足够小, 则直接求解
- __合并__ 这些子问题的解成原问题的解

#### 2.3.2 分析分治算法
可以用递归方程或递归式来描述其运行时间
假设把原问题分别成a个子问题, 每个子问题的规模是原问题的1/b. 为了求解一个规模为n/b的子问题, 需要T(n/b)的时间, 所以需要aT(n/b)的时间来求解a个子问题. 如果分解问题成子问题需要时间D(n), 合并子问题的解成原问题的解需要时间C(n).
T(n) = aT(n/b) + D(n) + C(n)

## 第三章 函数的增长
### 3.1 渐进记号
对所有的n≥n0, 函数f(n)在一个常量银子内等于g(n). 我们称g(n)是f(n)的一个 __渐进紧确界(asymptotically tight bound)__
O记号: 渐进上界
Ω记号: 渐进下界

### 3.2 标准记号与常用函数
多项式: 若对某个常量k, 有f(n)=O(n^k), 则称函数f(n)是多项式有界的
对数: 若对某个常量k, f(n)=O(lg^kn), 则称函数f(n)是多对数有界的

## 第四章 分治策略
当子问题足够大, 需要递归求解时, 我们称之 __递归情况(recursive case)__
当子问题变得足够小, 不再需要递归时, 我们说递归已经"触底", 进入了 __基本情况(base case)__

### 4.1 最大子数组问题
给出一段时间的股票价格变化, 确定买入卖出时间以获得最大收益
问题转化为寻找价格变化的和的最大非空连续子数组, __最大子数组(maximum subarray)__:
- 完全位于左边的子数组中, low≤i≤j≤mid
- 完全位于右边的子数组中, mid≤i≤j≤high
- 求取跨越中点的最大子数组, 因此low≤i≤mid<j≤high:
从中点开始分别向两端求取有最大和的子数组
时间复杂度为O(nlgn)
最优解:
从数组的左边界开始, 由左至右处理, 记录到目前为止已经处理过的最大子数组. 若已知A[1..j]的最大子数组, 基于以下性质将解扩展为A[1..j+1]的最大子数组: A[1..j+1]要么是A[1..j]的最大子数组, 要么是某个子数组A[1..j+1](1≤i≤j)

### 4.2 矩阵乘法的Strassen算法
我们可以不必复制元素就能完成矩阵的分解, 其中的诀窍是使用下标计算
虽然渐进符号包含了常数因子, 但递归符号(如T(n/2))并不包含

### 4.3 用代入法求解递归式
证明上界失败时, 不一定要将猜测减少, 实际上证明一个更弱的上界可能会更困难一些, 但因为为了证明一个更弱的上界, 我们在归纳证明中也必须使用同样更弱的界

### 4.4
